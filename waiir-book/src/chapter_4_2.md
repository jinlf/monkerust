# 求值策略

基于AST的解释器典型的求值策略是树遍历方式。有时会做一些简单的优化，这些优化会重写AST（例如删除未使用的变量绑定）或将其转换为更适合递归和重复求值的其它种类的中间表示（IR）。

有的解释器也遍历AST，但不是解释AST本身，而是先将其转换为字节码。字节码是AST的另一种非常密集的IR。字节码由虚拟机解释，这种方法可以产生巨大的性能优势。

有的策略是解析器不生成AST，而是直接生成字节码。这跟编译器的实现方式就更加类似了，有的策略甚至也不在虚拟机中直接执行字节码指定的操作，而是在执行之前即时将字节码编译为本地机器代码。形成所谓的JIT（即时）解释器/编译器。

有的策略是递归地遍历AST，在执行它的特定分支之前，将节点编译为本地机器代码，然后执行。这种也属于JIT方式。

上述策略的一个小变化是混合解释模式，其中解释器递归地求值AST，并且仅在多次求值AST的特定分支之后，才将分支编译为机器代码。

选择哪种策略很大程度上取决于性能、可移植性需求、编程语言特点以及开发者的意愿。 树遍历解释器是所有方法中最慢的，但易于构建，扩展，推理并与其实现的语言一样轻便。

编译为字节码并使用虚拟机求值所述字节码的解释器将会快很多。但是也更复杂，更难构建。

出于学习目的，本文实现最基础的树遍历解释器。
